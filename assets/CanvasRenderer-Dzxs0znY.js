import{q as T,k as Se,r as Me,s as ae,M as q,t as w,x as je,w as Ye,y as Ve,h as we,T as Ie,z as $e,A as Xe,D as Je,F as Ke,H as ze,J as Qe,K as Re,L as Ze,N as et,O as oe}from"./index-l5mn4eUm.js";import{R as tt,S as st,B as nt,a as at,b as rt,c as ot,A as it,C as ct}from"./RenderTargetSystem-DYOwIahI.js";import"./Filter-DB_vaceA.js";const ge=class ${static _getPatternRepeat(e,t){const s=e&&e!=="clamp-to-edge",a=t&&t!=="clamp-to-edge";return s&&a?"repeat":s?"repeat-x":a?"repeat-y":"no-repeat"}start(e,t,s){}execute(e,t){var i,h,f,g;const s=t.elements;if(!s||!s.length)return;const a=e.renderer,r=a.canvasContext,o=r.activeContext;for(let I=0;I<s.length;I++){const G=s[I];if(!G.packAsQuad)continue;const v=G,u=v.texture,R=u?T.getCanvasSource(u):null;if(!R)continue;const x=u.source.style,A=r.smoothProperty,U=x.scaleMode!=="nearest";o[A]!==U&&(o[A]=U),r.setBlendMode(t.blendMode);const E=((i=a.globalUniforms.globalUniformData)==null?void 0:i.worldColor)??4294967295,P=v.color,y=(E>>>24&255)/255,Y=(P>>>24&255)/255,ee=((h=a.filter)==null?void 0:h.alphaMultiplier)??1,z=y*Y*ee;if(z<=0)continue;o.globalAlpha=z;const Q=E&16777215,X=P&16777215,k=Me(ae(X,Q)),_=u.frame,S=x.addressModeU??x.addressMode,ie=x.addressModeV??x.addressMode,Z=$._getPatternRepeat(S,ie),D=u.source._resolution??u.source.resolution??1,V=(g=(f=v.renderable)==null?void 0:f.renderGroup)==null?void 0:g.isCachedAsTexture,d=_.x*D,p=_.y*D,m=_.width*D,L=_.height*D,M=v.bounds,b=a.renderTarget.renderTarget.isRoot,W=M.minX,F=M.minY,B=M.maxX-M.minX,H=M.maxY-M.minY,O=u.rotate,c=u.uvs,N=Math.min(c.x0,c.x1,c.x2,c.x3,c.y0,c.y1,c.y2,c.y3),j=Math.max(c.x0,c.x1,c.x2,c.x3,c.y0,c.y1,c.y2,c.y3),C=Z!=="no-repeat"&&(N<0||j>1),ce=O&&!(!C&&(k!==16777215||O));ce?($._tempPatternMatrix.copyFrom(v.transform),Se.matrixAppendRotationInv($._tempPatternMatrix,O,W,F,B,H),r.setContextTransform($._tempPatternMatrix,v.roundPixels===1,void 0,V&&b)):r.setContextTransform(v.transform,v.roundPixels===1,void 0,V&&b);const te=ce?0:W,se=ce?0:F,le=B,he=H;if(C){let de=R;const J=k!==16777215&&!O,K=_.width<=u.source.width&&_.height<=u.source.height;J&&K&&(de=T.getTintedCanvas({texture:u},k));const pe=o.createPattern(de,Z);if(!pe)continue;const xe=le,ye=he;if(xe===0||ye===0)continue;const Ce=1/xe,Te=1/ye,Pe=(c.x1-c.x0)*Ce,ke=(c.y1-c.y0)*Ce,be=(c.x3-c.x0)*Te,_e=(c.y3-c.y0)*Te,Oe=c.x0-Pe*te-be*se,Ne=c.y0-ke*te-_e*se,ue=u.source.pixelWidth,me=u.source.pixelHeight;$._tempPatternMatrix.set(Pe*ue,ke*me,be*ue,_e*me,Oe*ue,Ne*me),T.applyPatternTransform(pe,$._tempPatternMatrix),o.fillStyle=pe,o.fillRect(te,se,le,he)}else{const J=k!==16777215||O?T.getTintedCanvas({texture:u},k):R,K=J!==R;o.drawImage(J,K?0:d,K?0:p,K?J.width:m,K?J.height:L,te,se,le,he)}}}};ge._tempPatternMatrix=new q;ge.extension={type:[w.CanvasPipesAdaptor],name:"batch"};let lt=ge;class Ae{constructor(e){this._colorStack=[],this._colorStackIndex=0,this._currentColor=0,this._renderer=e}buildStart(){this._colorStack[0]=15,this._colorStackIndex=1,this._currentColor=15}push(e,t,s){this._renderer.renderPipes.batch.break(s);const a=this._colorStack;a[this._colorStackIndex]=a[this._colorStackIndex-1]&e.mask;const r=this._colorStack[this._colorStackIndex];r!==this._currentColor&&(this._currentColor=r,s.add({renderPipeId:"colorMask",colorMask:r,canBundle:!1})),this._colorStackIndex++}pop(e,t,s){this._renderer.renderPipes.batch.break(s);const a=this._colorStack;this._colorStackIndex--;const r=a[this._colorStackIndex-1];r!==this._currentColor&&(this._currentColor=r,s.add({renderPipeId:"colorMask",colorMask:r,canBundle:!1}))}execute(e){}destroy(){this._renderer=null,this._colorStack=null}}Ae.extension={type:[w.CanvasPipes],name:"colorMask"};function ht(n,e,t,s,a,r){r=Math.max(0,Math.min(r,Math.min(s,a)/2)),n.moveTo(e+r,t),n.lineTo(e+s-r,t),n.quadraticCurveTo(e+s,t,e+s,t+r),n.lineTo(e+s,t+a-r),n.quadraticCurveTo(e+s,t+a,e+s-r,t+a),n.lineTo(e+r,t+a),n.quadraticCurveTo(e,t+a,e,t+a-r),n.lineTo(e,t+r),n.quadraticCurveTo(e,t,e+r,t)}function Be(n,e){switch(e.type){case"rectangle":{const t=e;n.rect(t.x,t.y,t.width,t.height);break}case"roundedRectangle":{const t=e;ht(n,t.x,t.y,t.width,t.height,t.radius);break}case"circle":{const t=e;n.moveTo(t.x+t.radius,t.y),n.arc(t.x,t.y,t.radius,0,Math.PI*2);break}case"ellipse":{const t=e;n.ellipse?(n.moveTo(t.x+t.halfWidth,t.y),n.ellipse(t.x,t.y,t.halfWidth,t.halfHeight,0,0,Math.PI*2)):(n.save(),n.translate(t.x,t.y),n.scale(t.halfWidth,t.halfHeight),n.moveTo(1,0),n.arc(0,0,1,0,Math.PI*2),n.restore());break}case"triangle":{const t=e;n.moveTo(t.x,t.y),n.lineTo(t.x2,t.y2),n.lineTo(t.x3,t.y3),n.closePath();break}case"polygon":default:{const t=e,s=t.points;if(!(s!=null&&s.length))break;n.moveTo(s[0],s[1]);for(let a=2;a<s.length;a+=2)n.lineTo(s[a],s[a+1]);t.closePath&&n.closePath();break}}}function dt(n,e){if(!(e!=null&&e.length))return!1;for(let t=0;t<e.length;t++){const s=e[t];if(!(s!=null&&s.shape))continue;const a=s.transform,r=a&&!a.isIdentity();r&&(n.save(),n.transform(a.a,a.b,a.c,a.d,a.tx,a.ty)),Be(n,s.shape),r&&n.restore()}return!0}class He{constructor(e){this._warnedMaskTypes=new Set,this._canvasMaskStack=[],this._renderer=e}push(e,t,s){this._renderer.renderPipes.batch.break(s),s.add({renderPipeId:"stencilMask",action:"pushMaskBegin",mask:e,inverse:t._maskOptions.inverse,canBundle:!1})}pop(e,t,s){this._renderer.renderPipes.batch.break(s),s.add({renderPipeId:"stencilMask",action:"popMaskEnd",mask:e,inverse:t._maskOptions.inverse,canBundle:!1})}execute(e){var g,I,G;if(e.action!=="pushMaskBegin"&&e.action!=="popMaskEnd")return;const t=this._renderer,s=t.canvasContext,a=s==null?void 0:s.activeContext;if(!a)return;if(e.action==="popMaskEnd"){this._canvasMaskStack.pop()&&a.restore();return}e.inverse&&this._warnOnce("inverse","CanvasRenderer: inverse masks are not supported on Canvas2D; ignoring inverse flag.");const r=e.mask.mask;if(!(r instanceof je)){this._warnOnce("nonGraphics","CanvasRenderer: only Graphics masks are supported in Canvas2D; skipping mask."),this._canvasMaskStack.push(!1);return}const o=r,i=(g=o.context)==null?void 0:g.instructions;if(!(i!=null&&i.length)){this._canvasMaskStack.push(!1);return}a.save(),s.setContextTransform(o.groupTransform,(t._roundPixels|o._roundPixels)===1),a.beginPath();let h=!1,f=!1;for(let v=0;v<i.length;v++){const u=i[v],R=u.action;if(R!=="fill"&&R!=="stroke")continue;const x=u.data,A=(I=x==null?void 0:x.path)==null?void 0:I.shapePath;if(!((G=A==null?void 0:A.shapePrimitives)!=null&&G.length))continue;const U=A.shapePrimitives;for(let E=0;E<U.length;E++){const P=U[E];if(!(P!=null&&P.shape))continue;const y=P.transform,Y=y&&!y.isIdentity();Y&&(a.save(),a.transform(y.a,y.b,y.c,y.d,y.tx,y.ty)),Be(a,P.shape),f=dt(a,P.holes)||f,h=!0,Y&&a.restore()}}if(!h){a.restore(),this._canvasMaskStack.push(!1);return}f?a.clip("evenodd"):a.clip(),this._canvasMaskStack.push(!0)}destroy(){this._renderer=null,this._warnedMaskTypes=null,this._canvasMaskStack=null}_warnOnce(e,t){this._warnedMaskTypes.has(e)||(this._warnedMaskTypes.add(e),Ye(t))}}He.extension={type:[w.CanvasPipes],name:"stencilMask"};const l="source-over";function pt(){const n=Ve(),e=Object.create(null);return e.inherit=l,e.none=l,e.normal="source-over",e.add="lighter",e.multiply=n?"multiply":l,e.screen=n?"screen":l,e.overlay=n?"overlay":l,e.darken=n?"darken":l,e.lighten=n?"lighten":l,e["color-dodge"]=n?"color-dodge":l,e["color-burn"]=n?"color-burn":l,e["hard-light"]=n?"hard-light":l,e["soft-light"]=n?"soft-light":l,e.difference=n?"difference":l,e.exclusion=n?"exclusion":l,e.saturation=n?"saturation":l,e.color=n?"color":l,e.luminosity=n?"luminosity":l,e["linear-burn"]=n?"color-burn":l,e["linear-dodge"]=n?"color-dodge":l,e["linear-light"]=n?"hard-light":l,e["pin-light"]=n?"hard-light":l,e["vivid-light"]=n?"hard-light":l,e["hard-mix"]=l,e.negation=n?"difference":l,e["normal-npm"]=e.normal,e["add-npm"]=e.add,e["screen-npm"]=e.screen,e.erase="destination-out",e.subtract=l,e.divide=l,e.min=l,e.max=l,e}const ut=new q;class Ge{constructor(e){this.activeResolution=1,this.smoothProperty="imageSmoothingEnabled",this.blendModes=pt(),this._activeBlendMode="normal",this._projTransform=null,this._outerBlend=!1,this._warnedBlendModes=new Set,this._renderer=e}resolutionChange(e){this.activeResolution=e}init(){const e=this._renderer.background.alpha<1;if(this.rootContext=this._renderer.canvas.getContext("2d",{alpha:e}),this.activeContext=this.rootContext,this.activeResolution=this._renderer.resolution,!this.rootContext.imageSmoothingEnabled){const t=this.rootContext;t.webkitImageSmoothingEnabled?this.smoothProperty="webkitImageSmoothingEnabled":t.mozImageSmoothingEnabled?this.smoothProperty="mozImageSmoothingEnabled":t.oImageSmoothingEnabled?this.smoothProperty="oImageSmoothingEnabled":t.msImageSmoothingEnabled&&(this.smoothProperty="msImageSmoothingEnabled")}}setContextTransform(e,t,s,a){var f;const r=a?q.IDENTITY:((f=this._renderer.globalUniforms.globalUniformData)==null?void 0:f.worldTransformMatrix)||q.IDENTITY;let o=ut;o.copyFrom(r),o.append(e);const i=this._projTransform,h=this.activeResolution;if(s=s||h,i){const g=q.shared;g.copyFrom(o),g.prepend(i),o=g}t?this.activeContext.setTransform(o.a*s,o.b*s,o.c*s,o.d*s,o.tx*h|0,o.ty*h|0):this.activeContext.setTransform(o.a*s,o.b*s,o.c*s,o.d*s,o.tx*h,o.ty*h)}clear(e,t){const s=this.activeContext,a=this._renderer;if(s.clearRect(0,0,a.width,a.height),e){const r=we.shared.setValue(e);s.globalAlpha=t??r.alpha,s.fillStyle=r.toHex(),s.fillRect(0,0,a.width,a.height),s.globalAlpha=1}}setBlendMode(e){if(this._activeBlendMode===e)return;this._activeBlendMode=e,this._outerBlend=!1;const t=this.blendModes[e];if(!t){this._warnedBlendModes.has(e)||(console.warn(`CanvasRenderer: blend mode "${e}" is not supported in Canvas2D; falling back to "source-over".`),this._warnedBlendModes.add(e)),this.activeContext.globalCompositeOperation="source-over";return}this.activeContext.globalCompositeOperation=t}destroy(){this.rootContext=null,this.activeContext=null,this._warnedBlendModes.clear()}}Ge.extension={type:[w.CanvasSystem],name:"canvasContext"};class Ee{constructor(){this.maxTextures=16,this.maxBatchableTextures=16,this.maxUniformBindings=0}init(){}}Ee.extension={type:[w.CanvasSystem],name:"limits"};const mt="#808080",ne=new q,ft=new q,gt=new q,fe=new q;function vt(n,e,t){n.beginPath();for(let s=0;s<t.length;s+=3){const a=t[s]*2,r=t[s+1]*2,o=t[s+2]*2;n.moveTo(e[a],e[a+1]),n.lineTo(e[r],e[r+1]),n.lineTo(e[o],e[o+1]),n.closePath()}n.fill()}function xt(n){return`#${(n&16777215).toString(16).padStart(6,"0")}`}function yt(n,e,t,s,a,r){r=Math.max(0,Math.min(r,Math.min(s,a)/2)),n.moveTo(e+r,t),n.lineTo(e+s-r,t),n.quadraticCurveTo(e+s,t,e+s,t+r),n.lineTo(e+s,t+a-r),n.quadraticCurveTo(e+s,t+a,e+s-r,t+a),n.lineTo(e+r,t+a),n.quadraticCurveTo(e,t+a,e,t+a-r),n.lineTo(e,t+r),n.quadraticCurveTo(e,t,e+r,t)}function re(n,e){switch(e.type){case"rectangle":{const t=e;n.rect(t.x,t.y,t.width,t.height);break}case"roundedRectangle":{const t=e;yt(n,t.x,t.y,t.width,t.height,t.radius);break}case"circle":{const t=e;n.arc(t.x,t.y,t.radius,0,Math.PI*2);break}case"ellipse":{const t=e;n.ellipse?n.ellipse(t.x,t.y,t.halfWidth,t.halfHeight,0,0,Math.PI*2):(n.save(),n.translate(t.x,t.y),n.scale(t.halfWidth,t.halfHeight),n.arc(0,0,1,0,Math.PI*2),n.restore());break}case"triangle":{const t=e;n.moveTo(t.x,t.y),n.lineTo(t.x2,t.y2),n.lineTo(t.x3,t.y3),n.closePath();break}case"polygon":default:{const t=e,s=t.points;if(!(s!=null&&s.length))break;n.moveTo(s[0],s[1]);for(let a=2;a<s.length;a+=2)n.lineTo(s[a],s[a+1]);t.closePath&&n.closePath();break}}}function Ct(n,e){if(!(e!=null&&e.length))return!1;for(let t=0;t<e.length;t++){const s=e[t];if(!(s!=null&&s.shape))continue;const a=s.transform,r=a&&!a.isIdentity();r&&(n.save(),n.transform(a.a,a.b,a.c,a.d,a.tx,a.ty)),re(n,s.shape),r&&n.restore()}return!0}function Tt(n,e,t,s){const a=n.fill;if(a instanceof Ke){a.buildGradient();const o=a.texture;if(o){const i=T.getTintedPattern(o,e),h=t?fe.copyFrom(t).scale(o.source.pixelWidth,o.source.pixelHeight):fe.copyFrom(a.transform);return s&&!n.textureSpace&&h.append(s),T.applyPatternTransform(i,h),i}}if(a instanceof ze){const o=T.getTintedPattern(a.texture,e);return T.applyPatternTransform(o,a.transform),o}const r=n.texture;if(r&&r!==Ie.WHITE){if(!r.source.resource)return mt;const o=T.getTintedPattern(r,e),i=t?fe.copyFrom(t).scale(r.source.pixelWidth,r.source.pixelHeight):n.matrix;return T.applyPatternTransform(o,i),o}return xt(e)}class We{constructor(){this.shader=null}contextChange(e){}execute(e,t){var U,E,P,y,Y,ee,z;const s=e.renderer,a=s.canvasContext,r=a.activeContext,o=t.groupTransform,i=((U=s.globalUniforms.globalUniformData)==null?void 0:U.worldColor)??4294967295,h=t.groupColorAlpha,f=(i>>>24&255)/255,g=(h>>>24&255)/255,I=((E=s.filter)==null?void 0:E.alphaMultiplier)??1,G=f*g*I;if(G<=0)return;const v=i&16777215,u=h&16777215,R=Me(ae(u,v)),x=s._roundPixels|t._roundPixels;r.save(),a.setContextTransform(o,x===1),a.setBlendMode(t.groupBlendMode);const A=t.context.instructions;for(let Q=0;Q<A.length;Q++){const X=A[Q];if(X.action==="texture"){const d=X.data,p=d.image,m=p?T.getCanvasSource(p):null;if(!m)continue;const L=d.alpha*G;if(L<=0)continue;const M=ae(d.style,R);r.globalAlpha=L;let b=m;M!==16777215&&(b=T.getTintedCanvas({texture:p},M));const W=p.frame,F=p.source._resolution??p.source.resolution??1;let B=W.x*F,H=W.y*F;const O=W.width*F,c=W.height*F;b!==m&&(B=0,H=0);const N=d.transform,j=N&&!N.isIdentity(),C=p.rotate;j||C?(ne.copyFrom(o),j&&ne.append(N),C&&Se.matrixAppendRotationInv(ne,C,d.dx,d.dy,d.dw,d.dh),a.setContextTransform(ne,x===1)):a.setContextTransform(o,x===1),r.drawImage(b,B,H,b===m?O:b.width,b===m?c:b.height,C?0:d.dx,C?0:d.dy,d.dw,d.dh),(j||C)&&a.setContextTransform(o,x===1);continue}const k=X.data,_=(P=k==null?void 0:k.path)==null?void 0:P.shapePath;if(!((y=_==null?void 0:_.shapePrimitives)!=null&&y.length))continue;const S=k.style,ie=ae(S.color,R),Z=S.alpha*G;if(Z<=0)continue;const D=X.action==="stroke";if(r.globalAlpha=Z,D){const d=S;r.lineWidth=d.width,r.lineCap=d.cap,r.lineJoin=d.join,r.miterLimit=d.miterLimit}const V=_.shapePrimitives;if(!D&&((z=(ee=(Y=k.hole)==null?void 0:Y.shapePath)==null?void 0:ee.shapePrimitives)!=null&&z.length)){const d=V[V.length-1];d.holes=k.hole.shapePath.shapePrimitives}for(let d=0;d<V.length;d++){const p=V[d];if(!(p!=null&&p.shape))continue;const m=p.transform,L=m&&!m.isIdentity(),M=S.texture&&S.texture!==Ie.WHITE,b=S.textureSpace==="global"?m:null,W=M?$e(ft,S,p.shape,b):null,F=L?gt.copyFrom(o).append(m):o,B=Tt(S,ie,W,F);if(L&&(r.save(),r.transform(m.a,m.b,m.c,m.d,m.tx,m.ty)),D){const H=S;if(H.alignment!==.5&&!H.pixelLine){const c=[],N=[],j=[],C=Xe[p.shape.type];if(C!=null&&C.build(p.shape,c)){const ve=p.shape.closePath??!0;Je(c,H,!1,ve,N,j),r.fillStyle=B,vt(r,N,j)}else r.strokeStyle=B,r.beginPath(),re(r,p.shape),r.stroke()}else r.strokeStyle=B,r.beginPath(),re(r,p.shape),r.stroke()}else r.fillStyle=B,r.beginPath(),re(r,p.shape),Ct(r,p.holes)?r.fill("evenodd"):r.fill();L&&r.restore()}}r.restore()}destroy(){this.shader=null}}We.extension={type:[w.CanvasPipesAdaptor],name:"graphics"};class Pt{init(e,t){this._renderer=e,this._renderTargetSystem=t}initGpuRenderTarget(e){const t=e.colorTexture,{canvas:s,context:a}=this._ensureCanvas(t);return{canvas:s,context:a,width:s.width,height:s.height}}resizeGpuRenderTarget(e){const t=e.colorTexture,{canvas:s}=this._ensureCanvas(t);s.width=e.pixelWidth,s.height=e.pixelHeight}startRenderPass(e,t,s,a){const r=this._renderTargetSystem.getGpuRenderTarget(e);this._renderer.canvasContext.activeContext=r.context,this._renderer.canvasContext.activeResolution=e.resolution,t&&this.clear(e,t,s,a)}clear(e,t,s,a){const o=this._renderTargetSystem.getGpuRenderTarget(e).context,i=a||{x:0,y:0,width:e.pixelWidth,height:e.pixelHeight};if(o.setTransform(1,0,0,1,0,0),o.clearRect(i.x,i.y,i.width,i.height),s){const h=we.shared.setValue(s);h.alpha>0&&(o.globalAlpha=h.alpha,o.fillStyle=h.toHex(),o.fillRect(i.x,i.y,i.width,i.height),o.globalAlpha=1)}}finishRenderPass(){}copyToTexture(e,t,s,a,r){const i=this._renderTargetSystem.getGpuRenderTarget(e).canvas,h=t.source,{context:f}=this._ensureCanvas(h),g=(r==null?void 0:r.x)??0,I=(r==null?void 0:r.y)??0;return f.drawImage(i,s.x,s.y,a.width,a.height,g,I,a.width,a.height),h.update(),t}destroyGpuRenderTarget(e){}_ensureCanvas(e){let t=e.resource;(!t||!Qe.test(t))&&(t=Re.get().createCanvas(e.pixelWidth,e.pixelHeight),e.resource=t),(t.width!==e.pixelWidth||t.height!==e.pixelHeight)&&(t.width=e.pixelWidth,t.height=e.pixelHeight);const s=t.getContext("2d");return{canvas:t,context:s}}}class Fe extends tt{constructor(e){super(e),this.adaptor=new Pt,this.adaptor.init(e,this)}}Fe.extension={type:[w.CanvasSystem],name:"renderTarget"};class qe{constructor(e){}init(){}initSource(e){}generateCanvas(e){const t=Re.get().createCanvas(),s=t.getContext("2d"),a=T.getCanvasSource(e);if(!a)return t;const r=e.frame,o=e.source._resolution??e.source.resolution??1,i=r.x*o,h=r.y*o,f=r.width*o,g=r.height*o;return t.width=Math.ceil(f),t.height=Math.ceil(g),s.drawImage(a,i,h,f,g,0,0,f,g),t}getPixels(e){const t=this.generateCanvas(e);return{pixels:t.getContext("2d",{willReadFrequently:!0}).getImageData(0,0,t.width,t.height).data,width:t.width,height:t.height}}destroy(){}}qe.extension={type:[w.CanvasSystem],name:"texture"};const kt=[...st,Ge,Ee,qe,Fe],bt=[nt,at,rt,ot,it,He,Ae,ct],_t=[lt,We],Ue=[],De=[],Le=[];oe.handleByNamedList(w.CanvasSystem,Ue);oe.handleByNamedList(w.CanvasPipes,De);oe.handleByNamedList(w.CanvasPipesAdaptor,Le);oe.add(...kt,...bt,..._t);class It extends Ze{constructor(){const e={name:"canvas",type:et.CANVAS,systems:Ue,renderPipes:De,renderPipeAdaptors:Le};super(e)}}export{It as CanvasRenderer};
